/*
 * Razor Pages is a new feature of ASP.NET Core MVC that makes coding page-focused scenarios easier and more productive.
 * Keeps implementation logic and view models closer to the view implementation code. 
 * 
 * Not just for simple scenarios; everything that you can do with MVC you can do by using Razor pages like Routing, Models,
 * ActionResult, Tag Helpers, etc. 
 * 
 * Two parts:
 * Razor Page (UI/View in MVC)
 * Page Model (Contains Handlers, Models/View Models/Controller Action Methods)
 * 
 * Index.cshtml - razor view or UI of the pages
 * 
 * Index.cshtml.cs - the page model for the index razor page. Extends from the Page Model class. Defines the model for the view. 
 * Have handlers, which are like controller action methods. 
 * We only have GET handler, but we can add POST handler when we want to post something from our view on the page.
 * 
 * Microsoft.AspNetCore.App was the metapackage which contained all the features of .NET Core.
 * But, nowadays it is included as part of the .NET core installation itself, so you don't have to include that in the project
 * reference anymore. 
 * 
 * The purpose of the .csproj file is to reference the NuGet packages you may or may not use throughout the application and
 * the target framework. 
 * 
 * PROPERTIES - launchsettings
 * Profiles
 * IIS Express - which will launch IIS Express which will host hte app and start the browser
 * which will hit the URL
 * It will also set env variables to development in this case. 
 * E.g. ASPNETCORE_ENVIRONMENT: to Production instead of Development
 * 
 * BookListRazor - name of project, runs app as a command line app, applicationURL
 * 
 * WWWROOT
 * css, js, and lib files exist for separation of concerns between various parts of app
 * Has already placed css, bootstrap, js, jquery, validation for us
 * If we added an empty web app, we would have to add all those files ourselves. 
 * CSS/JS files placed in wwwroot, for all static files. 
 * 
 * PAGES - main folder
 * All pages you could want. 
 * Shared
 *  _Layout.cshtml
 *  _ValidationScriptsPartial.cshtml
 *  
 *  Partial views - partial pages something like user components, reuse in multiple places in
 *  website. _Layout.cshtml is the default master page for your application. Header/footer,
 *  all scripts you want in your application. 
 *  
 *  
 *  ValidationScripts - jquery and javascripts we use for validation.
 *  We can include this partital page. 
 *  
 * _VIEWIMPORTS HTML
 * You define that you want to include tag helpers in your application by adding
 * @addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
 * Don't have to define at the global level, you can do it only for some pages. 
 * You can define custom tag helpers, also at the page level. 
 * 
 * 
 * _VIEWSTART HTML
 * Master page for the application is "_Layout";
 * 
 * Whatever has been described so far has to do more with the configuration and master page
 * and user components.
 * 
 * THEN ERROR, INDEX, and PRIVACY pages - the actual pages. 
 * 
 * INDEX
 * All the UI with HTML, CSS
 * Where is the page behind or the model defined?
 * In Razor, we do not have controllers, but we have Index.cshtml.cs as the Model.
 * Inherits from Page Model.
 * Code behind the Index Page.
 * 
 * This format is not included in the normal, conventional ASP.NET Core Apps.
 * This is completely differently written and formatted - .cs file is the page model.
 * .cshtml is the view or razor page. 
 * 
 * ROUTING IN RAZOR PAGES
 * How to match URLs to correct resources on server.
 * Most straightforward - you map URLs to files on the disk.
 * 
 * Routing in ASP.NET Razor Pages maps URL to physical files on the disk.
 * Razor pages need a root folder - by default called Pages
 * you can configure another root folder in the application configuration services
 * method inside the Startup class, but that's beyond the scope of this course. 
 * Index.cshtml is a default document, if a filename is missing from a request,
 * the request will be mapped to index.cshtml
 * 
 * www.domain.com --> /Pages/Index.cshtml
 * www.domain.com --> /Pages/Index.cshtml
 * www.domain.com/account --> /Pages/account.cshtml
 *                            OR /Pages/account/Index.cshtml
 * 
 * TAG HELPERS
 * Introduced with ASP.NET Core
 * Enable server-side code to participate in creating and rendering HTML elements in Razor files.
 * Very focused around the HTML elements and much more natural to use. 
 * Similar to angular directives
 * Tag helpers are for server side rendering while angularjs directives are all about 
 * client side rendering. 
 * Tag helpers vs. HTML helpers
 * HTML helpers are really just methods throughout razor markup.
 * Tag helpers are much more focused around HTML elements and much more natural to use. 
 * Use them along with HTML elements like with over JS frameworks. 
 * 
 * @*-----------HTML Helper------------*@
 * @Html.Label("FirstName", "FirstName : ", new { @class = "form-control" })
 * 
 * @*-----------TAG Helper-------------*@
 * <label class="form-control" asp-for="FirstName"></label>
 * 
 * @*-----------HTML Helper------------*@
 * @Html.LabelFor((m=>m.FirstName, new { @class="col-md-2 control-label" })
 * 
 * @*-----------TAG Helper-------------*@
 * <label asp-for="FirstName" class=col-md-2 control-label"></label>
 * 
 * PROGRAM CLASS
 * Entry point for the application. 
 * When the runtime executes the app, it looks for main method and calls it. 
 * Initially starts as a command line application, main method configures asp.net core and starts it. 
 * 
 * DEPENDENCY INJECTION
 * Integral part of ASP.NET - this method adds services to the application to make them available
 * By default you will have services.AddrazorPages() -- we wanted razorpages.
 * 
 * CONFIGURE - configure HTTP request pipelines, specifies how app should respond to HTTP requests.
 * Consists of middleware
 * Browser --> request through pipeline 
 * We get back response
 * We can add Authentication, MVC, and static files as middleware.
 * Should be done in the sequential order.
 * The user should be authenticated before loading MVC or static files (HTML, CSS, JS files)
 * When data travels through pipelines, it gets manipulated by middleware. 
 * 
 * When browser makes a request, it arrives at a web server like IIS
 * IIS invokes the .NET runtime, which loads the CLR
 * And thne look for an entrry point in your app, finding it in the main method of the Program class and executes, which
 * Starts the internal web server in your app (Kestrel in our app)
 * The main method in the startup class would configure the app and the request would be routed from IIS to Kesterl and then
 * pushed to app, and then processed by middleware, and then generated response will be routed back TO Kestrel, routed back to IIS
 * This generates a browser response -- this is much better than System.Web old approaches, tied to IIS.
 * Pipeline approach is much better, we only plug in the middleware we need. Everything we plug in is in a separate assembly
 * exposed in a nuget.
 * 
 * Since system.web was tied to IIS and IIS is tied to Windows, you cannot run classic asp.net on servers other than IIS/Windows.
 * ASP.NET core apps can now be run on other OSs.
 * One web server we have is external like IIS, or RJ or Linux
 * Other is internal server hosted by our app.
 * Request from external web server are passed to internal and other way around. Most common internal web server is Kestrel.
 * Kestrel - lightweight web server which can only execute a request. Because of it, you need external web server to configure
 * security, hashing, etc. 
 * 
 * MIDDLEWARE/PIPELINES
 * When the request comes in to the server, the server then accesses the .net framework and puts the request into a context object.
 * Gets passed through middleware; if there's a response anywhere, the middleware will attach the response to the context object and
 * then pass it back through the pipeline to the server and then the response back to the browser.
 * 
 * If no response is created at the end of the pipeline, this will result in a 404 not found error. 
 * There may be a response in the middle that needs to be passed back immediately.
 * Typically, it will go through to the end.
 * The last piece of the middleware sends back the response which gets back to the server, which sends back context to browser.
 * 
 * The order of the pipeline is very important. It always gets passed from first to the last - authentication for example.
 * If not authorized, it will not pass to next middleware, but will immediately return unauthorized response. 
 * Should be added before other components.
 * 
 * APPSETTINGS.JSON
 * All of the app's settings are contained in a file named appsettings.json
 * Any changes to the appsettings.json file will require restarting the "Microsoft IIS Administration" service to take effect. 
 * You can add further information about dependnecies like security keys here. Can store that info remotely on a server.
 * Appsettings - place where you store all your settings when developing. In the future, we'll add more settings
 * like connection strings and we'll be accessing the variables isnide startup class when we use dependency injection. 
 * 
 * DEPENDENCY INJECTION
 * ASP.NET core is designed from scratch to support dependency injection, technique for achieving inversion of control between
 * classes and their dependencies.
 * NET core injects objects of dependency classes through constructor or method by using built-in IOC container.
 * IOC container is a framework for implementing automatic dependency injection.
 * It manages object creation and its lifetime, also injects dependencies through their class.
 * IOC container creates an object of a specified class and also injects dependency objects through constructor, prop, or method 
 * at runtime and disposes at appropriate time. We don't have to create/manage the objects manually.
 * Support for DI is built into ASP.NET Core.
 * Dependency Injection (DI) is a pattern that can help developers decouple the different pieces of their applications; 
 * a class or object has its dependent classes injected rather than creating them directly.
 * In ASP.NET core, both framework services and application services can be injected into your classes, rather than
 * being tightly coupled. 
 * 
 * E.g.
 * Bob thinks about hiking - supplies like maps, flashlights, protein bars in a backpack.
 * This bag acts as a container - he takes whatever he needs out of the container.
 * You put items you'll need in a container; they already exist when you need them.
 * 
 * 3 pages - we will need 3 func (emails, logs, database)
 * In the old days, we would create objects for emails, logs, and database in all 3 pages. 
 * 
 * With dependency injection, we have a dependnecy injection container - register the 3 classes inside container.
 * Whenever a page needs the functionality, we extract from the container rather than creating a new obj in indiv pages
 * It is created and registered in the container that we use.
 * This way, containers deal with creating, registering, and disposing off obj rather than creating in every page.
 * Efficient dependency injection compared to old approach. 
 */